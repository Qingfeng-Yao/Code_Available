PointRend：渲染思路做图像分割，显著提升Mask R-CNN性能
Facebook FAIR 实验室再次创新图像分割算法，这回使用的是图像渲染的思路。算法可作为神经网络模块集成，显著提升 Mask R-CNN 和 DeepLabV3 性能。实例分割是计算机视觉任务中一个重要的任务。传统的示例分割方法输入图像，并对图像的每个像素点进行预测，推断像素点所属的实例标签，并区分属于不同实例的像素点。然而，现有的方法可能会对光滑的像素点区分边界进行过度计算，导致本应当具有清晰、连续边界的实例边缘像素点被分错。为了解决这一问题，何恺明等提出了一种新的实例分割的方法，用来优化解决这个问题。提到何恺明，读者们都不会陌生。近年来，他在语义分割和实例分割领域做了很多开创性的工作，用来提升分割效果。例如，在实例分割方面提出全景分割的方法，在语义分割上则提出了效果惊人的 TensorMask。最近，Alexander Kirillov（一作）、吴育昕、何恺明等又从计算机渲染的角度出发，提出了一个名为 PointRend 的方法，更好地提升图像分割过程中的平滑性和分割细节效果。这一方法是否会对现有的网络架构带来很大影响？研究者表示，这一方法可作为已有的图像分割架构的一个模块来使用。他们在 Mask R- CNN 和 DeepLabV3 等模型上进行了测试，性能提升明显，而且算力占用很小。这篇论文的作者包括我们熟悉的何恺明和吴育昕，他们多次在一些研究中合作。此外还有与何恺明在 TensorMask 等论文中合作的 Ross Girshick。这篇论文的具体方法和效果如何？机器之心对其进行了编译整理。引言图像分割任务涉及到了将从规则的网格中采样的像素映射到同一网格上的（一个或一组）标签图（label map）。对于语义分割任务来说，标签图表示对每个像素的预测类别。而在实例分割任务中，每个被检测对象需要预测二元前景背景图。这些任务所使用的方法基本上都是基于卷积神经网络（CNN）构建的。用于图像分割任务的 CNN 通常基于规则网格运行：输入的是图像像素的规则网格，隐藏表征则是基于规则网格的特征向量，而输出则是基于规则网格的标签图。规则网格很方便，但在计算方面对图像分割而言未必完美。这些网络预测的标签图应当是基本平滑的，即邻近的像素通常使用同一个标签，因为高频区域限制在对象之间的稀疏边界。规则网格可能对平滑区域过采样，同时却对对象边界的欠采样。这样一来，在平滑区域进行过度计算，使得预测结果的轮廓变得模糊（见图 1 左上）。这样一来，图像分割方法通常基于低分辨率规则网格来预测标签，如在语义分割任务中输入的 1/8，或实例分割中的 28×28，以此作为欠采样和过采样之间的妥协。图 1：使用 PointRend 执行实例分割和使用传统方法的对比。传统方法（左）分割的时候图像分辨率低，分割效果差。数十年来，计算机图形学领域研究了很多类似的采样问题。例如，渲染器将模型（如 3D 网格）映射到点阵图像，即像素的规则网格。尽管输出是基于规则网格的，但计算并不按照网格来均匀分配。常见的图形学策略是，对图像平面中被自适应选择点的不规则子集计算出像素值。例如，[48] 中的典型细分（subdivision）技术获得了类四叉树采样模式，从而高效渲染出抗锯齿（anti-aliased，即边缘柔化）的高分辨率图像。遵循类似的思路，何恺明等研究者在研究中将图像分割视为渲染问题，并利用计算机图形学中的经典思想来高效地「渲染」高质量标签图（见图 1 左下）。研究者将这种思想实现为一个新型神经网络模块——PointRend，该网络使用细分策略来自适应地选择一组非均匀点，进而计算标签。PointRend 可被纳入到常用的实例分割元架构（如 Mask R-CNN [19]）和语义分割元架构（如 FCN [35]）。其细分策略利用比直接密集计算少一个数量级的浮点运算，高效地计算高分辨率分割图。PointRend 是通用模块，允许多种可能实现。抽象来看，PointRend 模块接受一或多个典型 CNN 特征图 f(x_i , y_i) 作为输入，这些特征图基于规则网格定义，输出基于更细粒度网格的高分辨率预测结果 p(x'_i , y'_i )。PointRend 不对输出网格上的所有点执行过度预测，而是仅对精心选择的点执行预测。为此，PointRend 对 f 执行内插，提取所选点的逐点特征表示，使用一个小型 point head 子网络基于这些逐点特征预测输出标签。本文将展示一种简单高效的 PointRend 实现。研究者在 COCO [29] 和 Cityscapes [9] 基准数据集上评估 PointRend 在实例分割和语义分割任务上的性能。定性来看，PointRend 能够高效计算对象之间的清晰边界，见图 2 和图 8。图 2：Mask R-CNN [19] + 标准掩码头的结果示例（左侧图像）vs Mask R-CNN + PointRend 的结果示例（右侧图像）。模型使用 ResNet-50 和 FPN。 图 8：模型在 Cityscapes 样本上的实例分割和语义分割结果研究者还观察到定量级别的性能提升，尽管这些任务基于的标准 IoU 度量指标（mask AP 和 mIoU）会偏向于对象内部像素，对边界改进相对不那么敏感。但是 PointRend 依然显著提升了 Mask RCNN 和 DeepLabV3 [5] 的性能。方法研究者将计算机视觉中的图像分割类比为计算机图形学中的图像渲染。所谓渲染，即是将模型（如 3D 网格）显示为像素的规则网格，即图像。尽管输出表示为规则网格，但其底层物理实体（如 3D 模型）是连续的，使用物理和几何推理（如光线追踪）可在图像平面的任意真值点查询其物理占用（physical occupancy）等属性。类似地，在计算机视觉中，我们可以将图像分割看作底层连续实体的占用图，而分割输出（预测标签的规则网格）基于它的「渲染」得到。该实体被编码为网络特征图，可以通过内插在任意点进行评估。训练参数化函数，并基于这些内插点的特征表示，进而预测占用。而这些参数化函数即等同于计算机图形学中的物理和几何推理。基于这种类比，研究者提出 PointRend（Pointbased Rendering，「基于点的渲染」），用点的表征来解决图像分割问题。PointRend 模块接受一或多个包含 C 个通道的典型 CNN 特征图 f ∈ R^(C×H×W)，每一个特征图都基于规则网格定义（其粗糙程度通常是图像网格的 4-16 倍），输出预测结果共有 K 个类别标签 p ∈ R^(K×H'×W')，输出基于不同分辨率（大概率分辨率更高）的规则网格。PointRend 模块包含三个主要组件：1. 点选择策略：选择少量真值点执行预测，避免对高分辨率输出网格中的所有像素进行过度计算；2. 对选中的每个点提取逐点特征表示：使用每个选中点在 f 规则网格上的 4 个最近邻点，利用 f 的双线性内插计算真值点的特征。因此，该方法能够利用 f 的通道维度中编码的子像素信息，来预测比 f 分辨率高的分割；3. point head：一个小型神经网络，用于基于逐点特征表示预测标签，它独立于每个点。PointRend 架构可应用于实例分割（如 Mask R-CNN [19]）和语义分割（如 FCN [35]）任务。在实例分割任务中，PointRend 应用于每个区域，通过对一组选中点执行预测，以从粗糙到细粒度的方式计算掩码（见图 3）。在语义分割任务中，整个图像被看作一个区域，因而我们可以在不损失通用性的情况下，在实例分割语境中描述 PointRend。下面我们来看 PointRend 三个主要组件的细节。图 3：PointRend 应用于实例分割任务选择点来执行推断和训练该方法的核心思想是灵活和自适应地在图像平面中选择点，进而预测分割标签。直观来看，这些点的位置应该较稠密地邻近高频区域，如对象边界，类似于光线追踪中的抗锯齿问题。研究者将这一想法应用于推断和训练。推断：用于推断的点选择策略受到计算机图形学中自适应细分（adaptive subdivision）这一经典技术的启发。该技术通过计算与其近邻的值显著不同的位置，来高效渲染高分辨率图像（如通过光线追踪）；其他位置的值则通过内插已经计算好的输出值来获得（从粗糙网格开始）。训练：在训练过程中，PointRend 还需要选择点来构建训练 point head 所需的逐点特征。原则上，点选择策略类似于推断过程中使用的细分策略。但是，细分策略使用的顺序步骤对于利用反向传播训练神经网络不那么友好。因此，训练过程使用基于随机采样的非迭代策略。逐点表示和 Point HeadPointRend 通过结合细粒度和粗细度预测特征这两种特征类型，来构建所选点的逐点特征。实验：实例分割表 1 对比了 PointRend 和 Mask R-CNN 中默认 4x 卷积 head 的性能。PointRend 在 COCO 和 Cityscapes 数据集上的性能均超过 Mask R-CNN 默认 head。表 1：PointRend vs Mask R-CNN 默认 4×卷积掩码 head 的性能对比。细分推断策略使用的浮点数和内存是默认 4×卷积 head 的 1/30 不到，但它让 PointRend 能够获得高分辨率预测结果（224×224），见下表 2。PointRend 忽略对象中粗粒度预测就已足够的区域，从而在计算量大幅减少的情况下输出与 Mask R-CNN 框架一样的高分辨率结果。 表 2：224×224 输出分辨率掩码的浮点数（乘加）和激活计数下表 3 展示了在不同输出分辨率和每个细分步骤不同选择点数量的情况下，PointRend 的细分推断性能。表 3：细分推断参数预测更高分辨率的掩码能够改进结果。尽管 AP 饱和，但当输出分辨率从低到高（比如从 56×56 到 224×224）时，视觉上的提升仍然很明显，参见图 7。 图 7：PointRend 的抗锯齿效果表 4 展示了 PointRend 在训练过程中使用不同点选择策略时的性能。 表 4：训练时不同点选择策略的性能，每个边界框中有 142 个点下表 5 展示了 PointRend 和基线的对比情况，PointRend 性能超过基线模型，且基线模型的训练时间比 PointRend 长，模型规模也比 PointRend 大。 表 5：基线模型和 PointRend 性能对比。基线模型比 PointRend 大，且其训练时间是 PointRend 的 3 倍。实验：语义分割下表 6 展示了 DeepLabV3 和 DeeplabV3 + PointRend 的对比情况。 表 6：DeeplabV3 + PointRend 在 Cityscapes 语义分割任务上的性能超过基线 DeepLabV3。在 res_4 阶段使用空洞卷积可以将推断时的输出分辨率提升二倍，参见 [5]。与之对比，PointRend 具备更高的 mIoU。定性提升也非常明显，参见图 8。图 8：模型在 Cityscapes 样本上的实例分割和语义分割结果。通过自适应地采样点，PointRend 对 32k 个点执行预测，并达到了 1024×2048 的分辨率（即 2M 点），参见图 9。图 9：PointRend 在语义分割任务中的推断下表 7 展示了，在 8 倍和 4 倍输出步幅变化的情况下，SemanticFPN+PointRend 的性能较 SemanticFPN 有所提升。 表 7：在 Cityscapes 语义分割任务中，SemanticFPN+PointRend 的性能超过基线 SemanticFPN。 本文来源：机器之心Pro 作者：魔王、一鸣如有侵权请联系删除
